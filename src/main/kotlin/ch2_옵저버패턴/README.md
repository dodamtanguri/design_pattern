# 2. Observer Pattern

마감일: 2024년 6월 4일
완료: No

# Observer Pattern

> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 개체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 1:N (ONE-TO-MANY) 의존성을 정의
>

### 1 : N (One to Many) 관계

### 느슨한 결합 : 객체들이 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미

⭐️ 객체 사이의 상호의존성을 최소화.

- 주제는 옵저버가 특정 인터페이스를 구현한다는 사실만 암.
- 옵저버는 언제든지 새로 추가할 수 있음.
- 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요 없음.
- 주제와 옵저버는 서로 독립적으로 재사용 가능.
- 주제나 옵저버가 달라져도 서로에게 영향❌

주로 `Subject Interface` 와 `Observer Interface`가 들어있는 클래스 디자인으로 구현


### Subject

- 주제를 나타내는 인터페이스
- 객체 → 옵저버 등록  : `registerObserver()`
- 옵저버 탈퇴 : `removeObserver()`
- 상태 업데이트 : `notifyObserver()`

### Observer

- 옵저버가 될 가능성이 있는 객체가 반드시 구현해야하는 인터페이스
- 주제의 상태가 바뀌었을 때
- 각 주제마다 여러 개의 옵저버가 있을 수 있음 `(1 : N 관계)`

### ConcreteSubject (= WeatherData)

- 주제 역할을 하는 구상 클래스( 클래스의 모든 메서드를 완벽하게 구현, 오퍼레이션의 실체가 존재하는 클래스) 가 반드시 구현해야하는 인터페이스
- 상태를 설정하고 알아내는 `getter/setter` 를 포함.

### ConcreteObserver(= ~Display)

- Observer 인터페이스만 구현 하면 무엇이든 옵저버 클래스가 될 수 있음.
- 특정 주제에 등록하여 연락을 받을 수 있음.

Push : 주제가 옵저버로 데이터를 보냄

Pull : 옵저버가 주제로부터 데이터를 끌고옴.

### ⭐️ 디자인 원칙

1. 어플리케이션에서 달라지는 부분과 달라지지 않은 부분을 분리한다
- 달라지는 부분을 떼어내서 캡슐화를 시켜줌.
- 옵저버 패턴 변경 사항 : 옵저버의 개수, 형식
1. 구현보다는 인터페이스에 맞춰서 프로그래밍
- 주제코드에 변경이 필요 X 새로운 옵저버 클래스가 인터페이스를 구현하면 됨.
- 자신의 역할에만 집중 할 수 있음.
1. 상속 보다는 구성
2. 상호작용하는 객체 사이에는 느슨한결합 사용

<aside>
💡 Observable

</aside>

- 클래스 ⭕️ 인터페이스 ❌ >> 서브클래스를 만들어야하고 이미 다른 슈퍼클래스를 확장하고 있는 클래스에 `Observable` 의 기능을 추가할 수 없음.
